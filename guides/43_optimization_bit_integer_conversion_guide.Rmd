---
title: "[43] Bit-integer conversion utilities Guide"
output:
  md_document:
    variant: gfm
output_dir: ../workshops
knitr:
  opts_knit:
    root.dir: ..
---

This tutorial complements `43_optimization_bit_integer_conversion.R` and unpacks the workshop on bit-integer conversion utilities. You will see how it advances the Optimization sequence while building confidence with base R and tidyverse tooling.

## Setup

- Ensure you have opened the `archr` project root (or set your working directory there) before running any code.
- Open the workshop script in RStudio so you can execute lines interactively with `Ctrl+Enter` or `Cmd+Enter`.
- Create a fresh R session to avoid conflicts with leftover objects from earlier workshops.

## Skills

- Navigate the script `43_optimization_bit_integer_conversion.R` within the Optimization module.
- Connect the topic "Bit-integer conversion utilities" to systems architecting decisions.
- Load packages with `library()` and verify they attach without warnings.
- Define custom functions to package repeatable logic.

## Process Overview









```mermaid
flowchart LR
    A[Load Packages] --> B[Create d1_1]
    B[Create d1_1] --> C[Create d3]
    C[Create d3] --> D[Run the Code Block]
```

## Application

### Step 1 – Load Packages

Load GA package. Attach GA to make its functions available.

```{r step_01, eval=FALSE}
library(GA)
```

### Step 2 – Run the Code Block

Test out our binary2decimal() function from GA.

```{r step_02, eval=FALSE}
binary2decimal(x = c(1,1))
```

### Step 3 – Define `bit2int()`

Let's try to code this up!

```{r step_03, eval=FALSE}
bit2int = function(x){
  # Testing value
  # x = c(0,0,0,1, 1,1, 1,1)
```

### Step 4 – Create `d1_1`

Decision 1 Converted to xhat.

```{r step_04, eval=FALSE}
  d1_1 = binary2decimal(x = x[1])
  d1_2 = binary2decimal(x = x[2])
  d1_3 = binary2decimal(x = x[3])
  d1_4 = binary2decimal(x = x[4])
```

### Step 5 – Run the Code Block

If all of decision 1 options are 0, then FAIL Reject if...

```{r step_05, eval=FALSE}
  if(d1_1 == 0 & d1_2 == 0 & d1_3 == 0 & d1_4 == 0){  return(NA)   }
```

### Step 6 – Create `d2`

Decision 2. Create the object `d2` so you can reuse it in later steps.

```{r step_06, eval=FALSE}
  d2 = binary2decimal(x[5:6])
  # Reject if...
  if( (d1_1 == 1 | d1_2 == 1 | d1_3 == 1) & d2 == 3){ return(NA)  }
  if( (d1_1 == 0 & d1_2 == 0 & d1_3 == 0 & d1_4 == 1) & d2 != 3){ return(NA)  }
```

### Step 7 – Create `d3`

Decision 3. Create the object `d3` so you can reuse it in later steps.

```{r step_07, eval=FALSE}
  d3 = binary2decimal(x[7:8])
  # Reject if...
  if( (d1_1 == 1 | d1_2 == 1 | d1_3 == 1) & d3 == 3){ return(NA)  }
  if( (d1_1 == 0 & d1_2 == 0 & d1_3 == 0 & d1_4 == 1) & d3 != 3){ return(NA)  }
```

### Step 8 – Create `xhat`

Bundle! Create the object `xhat` so you can reuse it in later steps.

```{r step_08, eval=FALSE}
  xhat = c(d1_1, d1_2, d1_3, d1_4, d2, d3)
  return(xhat)
}
```

### Step 9 – Run the Code Block

An invalid option returns NA.

```{r step_09, eval=FALSE}
bit2int(x = c(0,0,0,0, 1,1, 1,1))
# A valid option returns the integer string
bit2int(x = c(0,0,0,1, 1,1, 1,1))
```

## Learning Checks











**Learning Check 1.** What role does the helper `bit2int()` defined in Step 3 play in this workflow?

<details>
<summary>Show answer</summary>

It packages reusable logic needed by later steps.

</details>

**Learning Check 2.** Which libraries does Step 1 attach, and why do you run that chunk before others?

<details>
<summary>Show answer</summary>

It attaches GA, ensuring their functions are available before you execute the downstream code.

</details>

**Learning Check 3.** After Step 4, what does `d1_1` capture?

<details>
<summary>Show answer</summary>

It creates `d1_1`. Decision 1 Converted to xhat.

</details>

**Learning Check 4.** After Step 6, what does `d2` capture?

<details>
<summary>Show answer</summary>

It creates `d2` that returns the assembled object. Decision 2. Create the object `d2` so you can reuse it in later steps.

</details>
