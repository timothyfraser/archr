---
title: "[38] Recitation on main effects Guide"
output:
  md_document:
    variant: gfm
output_dir: ../workshops
knitr:
  opts_knit:
    root.dir: ..
---

This tutorial complements `38_evaluation_recitation_main_effects.R` and unpacks the workshop on recitation on main effects. You will see how it advances the Evaluation sequence while building confidence with base R and tidyverse tooling.

## Setup

- Ensure you have opened the `archr` project root (or set your working directory there) before running any code.
- Open the workshop script in RStudio so you can execute lines interactively with `Ctrl+Enter` or `Cmd+Enter`.
- Create a fresh R session to avoid conflicts with leftover objects from earlier workshops.

## Skills

- Navigate the script `38_evaluation_recitation_main_effects.R` within the Evaluation module.
- Connect the topic "Recitation on main effects" to systems architecting decisions.
- Load packages with `library()` and verify they attach without warnings.
- Chain tidyverse verbs with `%>%` to explore stakeholder or architecture tables.
- Define custom functions to package repeatable logic.
- Iterate on visualisations built with `ggplot2`.

## Application

### Step 1 – Practice the Pipe

Enumerate Architectures Example from Slides in Class.

```{r step_01, eval=FALSE}
data = enumerate_sf(n = c(2, 3, 2)) %>%
  # Add metrics
  mutate(m1 = c(33,73, 40, 80, 30, 70, 66, 146, 80, 160, 60, 140),
         m2 = c(0.8910, 0.9801, 0.8991, 0.9890, 0.4500, 0.4950, 0.9899, 0.9998, 0.9900, 0.9999, 0.7425, 0.7499))
```

### Step 2 – Run the Code Block

Execute the block and pay attention to the output it produces.

```{r step_02, eval=FALSE}
data
```

### Step 3 – Define `me()`

Create the helper function `me()` so you can reuse it throughout the workshop.

```{r step_03, eval=FALSE}
me = function(data, decision = "d2", value = 1, metric = "m1"){
  data2 = data %>%
    select(any_of(c(alt = decision, metric = metric))) %>%
    mutate(decision = decision) %>%
    select(decision, alt, metric)
  data3 = data2 %>%
    summarize(
      xhat = mean(metric[alt == value], na.rm = TRUE),
      x = mean(metric[alt != value], na.rm = TRUE),
      dbar = xhat - x  
    )
  output = data3$dbar
```

### Step 4 – Run the Code Block

Execute the block and pay attention to the output it produces.

```{r step_04, eval=FALSE}
  return(output)
}
```

### Step 5 – Create `me1`

Create the object `me1` so you can reuse it in later steps.

```{r step_05, eval=FALSE}
me1 = me(data, decision = "d2", value = 1, metric = "m1")
me2 = me(data, decision = "d2", value = 0, metric = "m1")
me3 = me(data, decision = "d2", value = 2, metric = "m1")
```

### Step 6 – Run the Code Block

Execute the block and pay attention to the output it produces.

```{r step_06, eval=FALSE}
(abs(me1) + abs(me2) + abs(me3)) / 3
```

### Step 7 – Run the Code Block

I'd suggest you use the final versions of these functions developed in: 00_sensitivity_connectivity_utilities.R.

```{r step_07, eval=FALSE}
source("workshops/00_sensitivity_connectivity_utilities.R")
```

### Step 8 – Run the Code Block

Let's try using this function to get sensitivity scores for every decision and metric.

```{r step_08, eval=FALSE}
sensitivity(data, decision_i = "d1", metric = "m1")
connectivity(data, decision_i = "d3", decisions = c("d1", "d2", "d3"), metric = "m1")
```

### Step 9 – Load Packages

Attach dplyr to make its functions available.

```{r step_09, eval=FALSE}
library(dplyr)
library(ggplot2)
```

### Step 10 – Create `data`

Create the object `data` so you can reuse it in later steps.

```{r step_10, eval=FALSE}
data = tibble(
  decision = c("D1", "D2", "D3", "D1", "D2", "D3"),
  sensitivity = c(5, 20, 30, 5, 10, 15),
  connectivity = c(8, 30, 20, 2, 5, 30),
  metric = c("cost", "cost", "cost", "benefit", "benefit", "benefit")
) %>%
  mutate(metric = case_when(
    metric == "cost" ~ "Cost (USD)",
    metric == "benefit" ~ "Range (Mi)"
  ))
```

### Step 11 – Create `quandrants`

Create the object `quandrants` so you can reuse it in later steps.

```{r step_11, eval=FALSE}
quandrants = tibble(
  label = c("Q1", "Q2", "Q3", "Q4"),
  sensitivity = c(18, 18, 12, 12),
  connectivity = c(18, 12,18,  12)
)
```

### Step 12 – Practice the Pipe

Use the `%>%` operator to pass each result to the next tidyverse verb.

```{r step_12, eval=FALSE}
divisions = data %>%
  summarize(sensitivity = (max(sensitivity) - 0) / 2,
            connectivity = (max(connectivity) - 0) / 2 )
```

### Step 13 – Create `gg`

Create the object `gg` so you can reuse it in later steps.

```{r step_13, eval=FALSE}
gg = ggplot() +
  # Plot points
  geom_point(
    data = data, 
    mapping = aes(
      x = connectivity, y = sensitivity, 
      color = metric),
    size = 15
  ) +
  # Plot labels for points on top
  geom_text(
    data = data,
    mapping = aes(
      x = connectivity, y = sensitivity,
      label = decision
    )
  ) +
  # geom_hline(yintercept = 15) +
  # geom_vline(xintercept = 15) +
  geom_hline(data = divisions, mapping = aes(yintercept = sensitivity)) +
  geom_vline(data = divisions, mapping = aes(xintercept = connectivity)) +
  # Pop some labels for quandrants
  geom_text(
    data = quandrants,
    mapping = aes(
      x = sensitivity, y = connectivity,
      label = label),
    color = "darkgrey"
    ) +
  theme_bw() +
  # Specify the limits
  scale_y_continuous(limits = c(0, 30)) +
  scale_x_continuous(limits = c(0, 30)) +
  # Put legend on bottom
  theme(legend.position = "bottom")
```

### Step 14 – Run the Code Block

Split up into panels.

```{r step_14, eval=FALSE}
gg + 
  facet_wrap(~metric, scales = "free")
```

## Learning Checks

**Learning Check 1.** How do you run the entire workshop script after you have stepped through each section interactively?

<details>
<summary>Show answer</summary>

Use `source(file.path("workshops", "38_evaluation_recitation_main_effects.R"))` from the Console or press the Source button while the script is active.

</details>

**Learning Check 2.** Why does the script begin by installing or loading packages before exploring the exercises?

<details>
<summary>Show answer</summary>

Those commands make sure the required libraries are available so every subsequent code chunk runs without missing-function errors.

</details>

**Learning Check 3.** How does the `%>%` pipeline help you reason about multi-step transformations in this script?

<details>
<summary>Show answer</summary>

It keeps each operation in sequence without creating temporary variables, so you can narrate the data story line by line.

</details>

**Learning Check 4.** How can you build confidence that a newly defined function behaves as intended?

<details>
<summary>Show answer</summary>

Call it with the sample input from the script, examine the output, then try a new input to see how the behaviour changes.

</details>

**Learning Check 5.** What experiment can you run on the `ggplot` layers to understand how aesthetics map to data?

<details>
<summary>Show answer</summary>

Switch one aesthetic (for example `color` to `fill` or tweak the geometry) and re-run the chunk to observe the difference.

</details>
